export const meta = {
  title: "Kafka Architecture",
  slug: "/blog/queueing-architecture",
  filename: "/blog/queueing-architecture",
  updatedAt: "2019-09-15",
  featuredImage: "kafka_diagram.png",
  tags: "programming,queueing"
}
import { BlogLayout } from '../../components/layouts/blogLayout';
export default ({ children }) => <BlogLayout meta={meta}>{children}</BlogLayout>

The above diagram, generated here details how we deploy our Next.JS app, aka the
app you're currently interfacing with, with a git-flow managed my Vercel.

Upon each push to a non-`main` branch, a Vercel deployment is created with
environment variables that speak to our staging Kubernetes server and SaaS
services. When a push to the `main` branch happens, our production Vercel
deployment is updated with the latest commit.

These Vercel hooks run no matter what code in our codebase is changed.
