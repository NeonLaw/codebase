export const meta = {
  title: "Neon Law Git Flow",
  slug: "/blog/neon-law-git-flow",
  filename: "/blog/neon-law-git-flow",
  updatedAt: "2021-06-01",
  tags: "programming,git-flow",
  widescreen: "true",
  description: "Instead of having multiple release branches, have one `main` branch and use GitHub releases.",
};
import { BlogLayout } from '../../components/layouts/blogLayout';
export default ({ children }) => <BlogLayout meta={meta}>{children}</BlogLayout>

> We have codified our git flow as a Rust Crate, which you can find at our
> [GitHub repo](https://github.com/neonlaw/codebase/blob/main/git_flow).

[Git Flow](https://nvie.com/posts/a-successful-git-branching-model/) is a
workflow for teams using GitHub to version releases of their software. There are
many great reasons why a team should adopt them, especially if your team ships
versioned software like Desktop or CLI apps you don't have much visibility into.

However, for us, everything we do is at neonlaw.com, or staged at neonlaw.net.
We don't distribute Desktop or CLI apps because we encourage everyone to use our
website. As a result, we do everything from one `main` branch, which you
can see in our [GitHub repository](https://github.com/neonlaw/codebase). We
implement Continuous Deployment in a much simpler way than GitFlow.

We then enforce conventions with our Git Flow CLI, which you can
see in our codebase. This CLI enforces branch names, what files are in a
supposed branch, GitHub labels, releases, and more. In our opinion we want
developers to have *more* rules because these rules can be automated and
subsequently remove ambiguity while working on a team.
